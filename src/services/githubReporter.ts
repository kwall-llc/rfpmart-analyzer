import { AIAnalysisResult } from './aiAnalyzer';
import { RFPListing } from '../scrapers/rfpMartScraper';
import { analyzerLogger } from '../utils/logger';
import { DatabaseManager } from '../storage/database';
import fs from 'fs-extra';
import path from 'path';

export interface GitHubReportOptions {
  outputDirectory: string;
  generateGitHubPages?: boolean;
  createActionSummary?: boolean;
  maxRFPsToShow?: number;
}

export class GitHubReporter {
  private databaseManager: DatabaseManager;

  constructor() {
    this.databaseManager = new DatabaseManager();
  }

  /**
   * Generate GitHub-friendly reports
   */
  async generateGitHubReports(options: GitHubReportOptions): Promise<void> {
    try {
      await this.databaseManager.initialize();
      
      analyzerLogger.info('Generating GitHub reports', { options });

      // Create output directory
      await fs.ensureDir(options.outputDirectory);

      // Get analysis data
      const stats = await this.databaseManager.getAIAnalysisStats();
      const recentRFPs = await this.databaseManager.getAllAIAnalysis({
        limit: options.maxRFPsToShow || 50,
        orderBy: 'analysis_date',
        orderDirection: 'DESC'
      });

      // Generate main dashboard
      await this.generateMainDashboard(stats, recentRFPs, options.outputDirectory);

      // Generate individual RFP pages
      await this.generateRFPPages(recentRFPs, options.outputDirectory);

      // Generate GitHub Pages index if requested
      if (options.generateGitHubPages) {
        await this.generateGitHubPagesIndex(stats, recentRFPs, options.outputDirectory);
      }

      // Generate GitHub Action summary if requested
      if (options.createActionSummary) {
        await this.generateActionSummary(stats, recentRFPs);
      }

      analyzerLogger.info('GitHub reports generated successfully');

    } catch (error) {
      analyzerLogger.error('Failed to generate GitHub reports', {
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    } finally {
      await this.databaseManager.close();
    }
  }

  /**
   * Generate main dashboard markdown
   */
  private async generateMainDashboard(
    stats: any,
    rfps: Array<AIAnalysisResult & { analysisDate: string }>,
    outputDir: string
  ): Promise<void> {
    const excellentRFPs = rfps.filter(r => r.fitRating === 'excellent');
    const goodRFPs = rfps.filter(r => r.fitRating === 'good');
    const currentDate = new Date().toLocaleDateString();

    const content = `# üéØ KWALL RFP Analysis Dashboard

*Last updated: ${currentDate}*

## üìä Summary Statistics

| Metric | Count |
|--------|--------|
| **Total RFPs Analyzed** | ${stats.totalAnalyzed} |
| **üéØ Excellent Fit** | ${stats.excellentFit} |
| **‚úÖ Good Fit** | ${stats.goodFit} |
| **‚ö†Ô∏è Poor Fit** | ${stats.poorFit} |
| **‚ùå Rejected** | ${stats.rejected} |
| **üìà Average Score** | ${stats.averageScore}/100 |
| **üéöÔ∏è Average Confidence** | ${stats.averageConfidence}% |

---

## üéØ Excellent Fit RFPs (${excellentRFPs.length})

*These RFPs are highly recommended for pursuit*

${excellentRFPs.length > 0 ? excellentRFPs.map(rfp => this.formatRFPSummary(rfp, 'excellent')).join('\n\n') : '*No excellent fit RFPs found.*'}

---

## ‚úÖ Good Fit RFPs (${goodRFPs.length})

*These RFPs are worth pursuing*

${goodRFPs.length > 0 ? goodRFPs.map(rfp => this.formatRFPSummary(rfp, 'good')).join('\n\n') : '*No good fit RFPs found.*'}

---

## üìã All Recent RFPs

| RFP | Score | Rating | Institution | Project Type | Analysis Date |
|-----|-------|--------|-------------|--------------|---------------|
${rfps.slice(0, 20).map(rfp => `| [${this.truncateTitle(rfp.rfpId)}](rfps/${rfp.rfpId}.md) | ${rfp.fitScore}/100 | ${this.getRatingEmoji(rfp.fitRating)} ${rfp.fitRating} | ${rfp.institutionType} | ${rfp.projectType} | ${new Date(rfp.analysisDate).toLocaleDateString()} |`).join('\n')}

---

## üìÅ Quick Links

- üìä [View All RFPs](rfps/)
- üìà [Analysis Statistics](#-summary-statistics)
- üéØ [Excellent Fits](#-excellent-fit-rfps-${excellentRFPs.length})
- ‚úÖ [Good Fits](#-good-fit-rfps-${goodRFPs.length})

*Generated by KWALL RFP Analyzer on ${new Date().toLocaleString()}*
`;

    await fs.writeFile(path.join(outputDir, 'README.md'), content);
  }

  /**
   * Generate individual RFP pages
   */
  private async generateRFPPages(
    rfps: Array<AIAnalysisResult & { analysisDate: string }>,
    outputDir: string
  ): Promise<void> {
    const rfpsDir = path.join(outputDir, 'rfps');
    await fs.ensureDir(rfpsDir);

    // Generate RFPs index
    const indexContent = `# üìã All RFP Analysis Results

*Total RFPs: ${rfps.length}*

${rfps.map(rfp => `## [${rfp.rfpId}](${rfp.rfpId}.md)
**Score:** ${rfp.fitScore}/100 | **Rating:** ${this.getRatingEmoji(rfp.fitRating)} ${rfp.fitRating}  
**Institution:** ${rfp.institutionType} | **Project:** ${rfp.projectType}  
**Analysis Date:** ${new Date(rfp.analysisDate).toLocaleDateString()}

---`).join('\n\n')}

[‚Üê Back to Dashboard](../README.md)
`;

    await fs.writeFile(path.join(rfpsDir, 'README.md'), indexContent);

    // Generate individual RFP pages
    for (const rfp of rfps) {
      const rfpContent = this.generateRFPPage(rfp);
      await fs.writeFile(path.join(rfpsDir, `${rfp.rfpId}.md`), rfpContent);
    }
  }

  /**
   * Generate individual RFP page
   */
  private generateRFPPage(rfp: AIAnalysisResult & { analysisDate: string }): string {
    return `# ${rfp.rfpId} - Analysis Report

## üìä Fit Analysis

| Field | Value |
|-------|-------|
| **Fit Score** | ${rfp.fitScore}/100 |
| **Fit Rating** | ${this.getRatingEmoji(rfp.fitRating)} **${rfp.fitRating.toUpperCase()}** |
| **Confidence** | ${rfp.confidence}% |
| **Analysis Date** | ${new Date(rfp.analysisDate).toLocaleString()} |

## üìù Analysis Summary

${rfp.reasoning}

## üèõÔ∏è Institution Details

| Field | Value |
|-------|-------|
| **Institution Type** | ${rfp.institutionType} |
| **Project Type** | ${rfp.projectType} |
| **Budget Estimate** | ${rfp.budgetEstimate} |

## üîß Technical Requirements

${rfp.technologies.length > 0 ? `
**Technologies:**
${rfp.technologies.map(tech => `- ${tech}`).join('\n')}
` : '*No specific technologies identified*'}

## üìã Key Requirements

${rfp.keyRequirements.length > 0 ? `
${rfp.keyRequirements.map(req => `- ${req}`).join('\n')}
` : '*No specific requirements identified*'}

${rfp.opportunities.length > 0 ? `
## üéØ Opportunities

${rfp.opportunities.map(opp => `- ${opp}`).join('\n')}
` : ''}

${rfp.redFlags.length > 0 ? `
## ‚ö†Ô∏è Red Flags

${rfp.redFlags.map(flag => `- ${flag}`).join('\n')}
` : ''}

## üíº Recommendation

**${rfp.recommendation}**

---

[‚Üê Back to RFPs](README.md) | [‚Üê Back to Dashboard](../README.md)

*Generated by KWALL RFP Analyzer*
`;
  }

  /**
   * Generate GitHub Pages index
   */
  private async generateGitHubPagesIndex(
    stats: any,
    rfps: Array<AIAnalysisResult & { analysisDate: string }>,
    outputDir: string
  ): Promise<void> {
    const pagesDir = path.join(outputDir, 'docs');
    await fs.ensureDir(pagesDir);

    // Copy main README as index
    const readmeContent = await fs.readFile(path.join(outputDir, 'README.md'), 'utf8');
    await fs.writeFile(path.join(pagesDir, 'index.md'), readmeContent);

    // Create _config.yml for GitHub Pages
    const configContent = `title: KWALL RFP Analysis Dashboard
description: Daily RFP Analysis Results & Good Fit Opportunities
theme: minima
markdown: kramdown
highlighter: rouge

plugins:
  - jekyll-feed
  - jekyll-sitemap

header_pages:
  - index.md
  - rfps/README.md

navigation:
  - title: Home
    url: /
  - title: All RFPs
    url: /rfps/
`;

    await fs.writeFile(path.join(pagesDir, '_config.yml'), configContent);

    // Copy RFPs directory
    await fs.copy(path.join(outputDir, 'rfps'), path.join(pagesDir, 'rfps'));
  }

  /**
   * Generate GitHub Action summary
   */
  private async generateActionSummary(
    stats: any,
    rfps: Array<AIAnalysisResult & { analysisDate: string }>
  ): Promise<void> {
    const excellentRFPs = rfps.filter(r => r.fitRating === 'excellent');
    const goodRFPs = rfps.filter(r => r.fitRating === 'good');

    const summary = `## üéØ RFP Analysis Summary

### üìä Statistics
- **Total Analyzed:** ${stats.totalAnalyzed}
- **üéØ Excellent Fit:** ${stats.excellentFit}
- **‚úÖ Good Fit:** ${stats.goodFit}
- **üìà Average Score:** ${stats.averageScore}/100

### üèÜ Top Opportunities

${excellentRFPs.length > 0 ? `
#### üéØ Excellent Fit RFPs
${excellentRFPs.slice(0, 3).map(rfp => `- **${rfp.rfpId}** (${rfp.fitScore}/100) - ${rfp.institutionType}, ${rfp.projectType}`).join('\n')}
` : ''}

${goodRFPs.length > 0 ? `
#### ‚úÖ Good Fit RFPs  
${goodRFPs.slice(0, 3).map(rfp => `- **${rfp.rfpId}** (${rfp.fitScore}/100) - ${rfp.institutionType}, ${rfp.projectType}`).join('\n')}
` : ''}

### üìÅ View Full Results
- [üìä Complete Dashboard](https://github.com/` + '${{ github.repository }}' + `/blob/main/reports/README.md)
- [üìã All RFPs](https://github.com/` + '${{ github.repository }}' + `/blob/main/reports/rfps/README.md)

*Analysis completed at ${new Date().toLocaleString()}*
`;

    // Write to GitHub Actions summary
    if (process.env.GITHUB_STEP_SUMMARY) {
      await fs.appendFile(process.env.GITHUB_STEP_SUMMARY, summary);
    }

    // Also save as file for manual viewing
    await fs.writeFile('action-summary.md', summary);
  }

  /**
   * Format RFP summary for dashboard
   */
  private formatRFPSummary(rfp: AIAnalysisResult & { analysisDate: string }, type: string): string {
    const emoji = type === 'excellent' ? 'üéØ' : '‚úÖ';
    
    return `### ${emoji} [${rfp.rfpId}](rfps/${rfp.rfpId}.md)

**Score:** ${rfp.fitScore}/100 | **Confidence:** ${rfp.confidence}%  
**Institution:** ${rfp.institutionType} | **Project:** ${rfp.projectType}  
**Budget:** ${rfp.budgetEstimate}

**Analysis:** ${rfp.reasoning.substring(0, 200)}...

${rfp.opportunities.length > 0 ? `**Key Opportunities:** ${rfp.opportunities.slice(0, 3).join(', ')}` : ''}

**Recommendation:** ${rfp.recommendation}`;
  }

  /**
   * Get emoji for rating
   */
  private getRatingEmoji(rating: string): string {
    switch (rating) {
      case 'excellent': return 'üéØ';
      case 'good': return '‚úÖ';
      case 'poor': return '‚ö†Ô∏è';
      case 'rejected': return '‚ùå';
      default: return '‚ùì';
    }
  }

  /**
   * Truncate title for table display
   */
  private truncateTitle(title: string, maxLength: number = 40): string {
    return title.length > maxLength ? title.substring(0, maxLength) + '...' : title;
  }
}