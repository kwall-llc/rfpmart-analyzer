# Advanced Claude Code Skills - MCP Integration

## Sequential Thinking Integration for Firebase Architecture

### Complex Problem Solving Patterns
- **Multi-tenant security analysis**: Break down organization access patterns systematically
- **Performance bottleneck investigation**: Analyze Firebase Function cold starts, Firestore query patterns
- **AI cost optimization**: Sequential analysis of prompt efficiency and token usage

### Firebase-Specific Sequential Workflows

#### Security Audit Workflow
```
1. Analyze authentication flows across all Firebase Functions
2. Review Firestore security rules for organization isolation  
3. Check for data leakage between tenants
4. Validate role-based access control implementation
5. Test edge cases with sequential penetration testing
```

#### Performance Optimization Workflow
```
1. Identify performance bottlenecks using sequential monitoring
2. Analyze Firestore read/write patterns systematically
3. Optimize Firebase Function cold start times
4. Review bundle size and React component performance
5. Implement caching strategies with sequential validation
```

#### AI Feature Optimization Workflow
```
1. Analyze current AI prompt patterns and token usage
2. Identify opportunities for context optimization
3. Implement prompt caching strategies
4. Optimize API call patterns for cost efficiency
5. Validate improvements with A/B testing
```

## Memory Integration for Context Persistence

### Project Knowledge Graph
- **Architecture Decisions**: Store and recall architectural patterns and decisions
- **Bug Patterns**: Remember common issues and their solutions
- **Performance Insights**: Persistent memory of optimization strategies
- **User Feedback**: Track user experience improvements over time

### Memory Categories for Firebase Project
```
entities:
  - Firebase Functions (with performance characteristics)
  - React Components (with usage patterns)
  - API Integrations (with rate limits and patterns)
  - User Workflows (with optimization history)

relationships:
  - Function → Component dependencies
  - Performance → User experience correlations
  - Security → Multi-tenant patterns
  - Cost → Usage optimization strategies
```

## Enhanced Filesystem Operations

### Advanced File Operations
- **Bulk file analysis**: Process multiple Firebase Functions simultaneously
- **Pattern detection**: Identify code patterns across React components
- **Automated refactoring**: Apply systematic changes across the codebase
- **Documentation generation**: Auto-generate API docs from Firebase Functions

### Project-Specific File Patterns
```
patterns:
  functions/*.js: Firebase Function analysis and optimization
  src/components/*: React component pattern recognition
  tests/*: Test coverage analysis and gap identification
  docs/*: Documentation completeness validation
```

## Tool Orchestration with MCP Servers

### Multi-Server Workflows
```
1. Sequential Thinking → Plan complex refactoring
2. Filesystem → Analyze current code patterns  
3. Memory → Recall previous optimization strategies
4. Firebase → Implement and test changes
5. GitHub → Create PR with detailed analysis
```

### Performance Monitoring Workflow
```
1. Memory → Recall baseline performance metrics
2. Sequential Thinking → Plan performance analysis approach
3. Firebase → Monitor function execution times
4. Playwright → Test frontend performance impact
5. Memory → Store new performance insights
```

## AI-Driven Development Patterns

### Context-Aware Code Generation
- Use Memory to recall successful patterns
- Apply Sequential Thinking for complex feature planning
- Leverage Filesystem for comprehensive code analysis
- Integrate Firebase MCP for real-time testing

### Quality Assurance Integration
- Sequential analysis of test coverage gaps
- Memory-based tracking of recurring issues
- Filesystem-based pattern validation
- Automated quality gate enforcement

## Cost Optimization Strategies

### AI Token Management
- Memory-based tracking of prompt efficiency
- Sequential optimization of context usage
- Pattern recognition for cost-effective prompts
- Automated budget monitoring and alerts

### Development Velocity Optimization
- Memory-based learning from development patterns
- Sequential planning for feature development
- Filesystem-based code reuse identification
- Automated workflow optimization suggestions